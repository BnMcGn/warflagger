(in-package :warflagger)

;;FIXME: duplicated in javascript: components.lisp. Update in both places.
(defun make-id-path (id)
  "Will put 1000 per dir for now"
  (if (< id 1000)
      "/0000/"
      (strcat "/"
              (let ((strid (princ-to-string id)))
                (subseq strid 0 (- (length strid) 3)))
              "000/")))

(defparameter *warstats-path-types*
  '(:opinion "opinion-data.json"
    :tree "tree.json"
    :warstats "warstats.json"
    :references "references.json"
    :questions "questions.json"
    :opinions "opinions.json"
    :author "author.json"
    :text "page.txt"))

(defun make-subpath (id type)
  (format nil "~a~a/~a"
          (make-id-path id) id (getf *warstats-path-types* type)))

(defun make-warstats-path (id type)
  (strcat wf/local-settings:*warstats-path* (make-subpath id type)))

(defun make-warstats-url (id type)
  (strcat "/static/warstats" (make-subpath id type)))

(defgeneric js-compatible-utcstamp (date))

(defmethod js-compatible-utcstamp ((date local-time:timestamp))
  (let ((tformat '((:year 4) #\- (:month 2) #\- (:day 2) #\T
                   (:hour 2) #\: (:min 2) #\: (:sec 2) "+0000")))
    (local-time:format-timestring
     nil
     date
     :format tformat :timezone local-time:+utc-zone+)))

(defmethod js-compatible-utcstamp ((date integer))
  (js-compatible-utcstamp (local-time:universal-to-timestamp date)))

(defmethod js-compatible-utcstamp ((date clsql:wall-time))
  (js-compatible-utcstamp (clsql-helper:clsql-date/times->utime date)))

(defmethod json:encode-json ((object clsql-sys:wall-time) &optional stream)
  ;(write-char #\" stream)
  (write (js-compatible-utcstamp object) :stream stream)
  ;;FIXME: quick hack to make this work on the live server (GMT). Javascript is touchy
  ;; about parsing dates.
                                        ;(write-char #\" stream)
  )

(defmethod json:encode-json ((object local-time:timestamp) &optional stream)
  (write-char #\" stream)
  ;; FIXME: verify correct. Who uses local-time?
  (local-time:format-timestring
   stream object
   :format '((:year 4) #\- (:month 2) #\- (:day 2) #\T
             (:hour 2) #\: (:min 2) #\: (:sec 2) :gmt-offset-hhmm))
  (write-char #\" stream))


;;;;;;;;;;;;;;;;;;;;;;;;
;; Gather the opinion data
;;;;;;;;;;;;;;;;;;;;;;;;

(defun %fill-out-opinion-tree (tree text)
  (if (null tree)
      nil
      (let ((op (opinion-by-id (caar tree) :extra t :text text)))
        (cons
         (cons
          op
          (%fill-out-opinion-tree (cdar tree)
                                  (create-textdata
                                   (aif (assoc :comment op) (cdr it) ""))))
         (%fill-out-opinion-tree (cdr tree) text)))))

(defun %warstats-pathdata-for-url (url)
  (multiple-value-bind (rid rtype)
      (get-target-id-from-url url)
    (when rid
      (values
       (list (case rtype
               (:rooturl rid)
               (:opinion (assoc-cdr :rootid (opinion-by-id rid)))
               (otherwise (error "Unknown type")))
             :warstats)
       rid rtype))))

(defun %tidy-loaded-json (json)
  (hu:alist->hash
   (mapcar (lambda (x)
             (cons
              (let ((sym (string-unless-number (mkstr (car x)))))
                (if (numberp sym) sym (car x)))
              (hu:alist->plist (cdr x))))
           json)))

(defun request-warstats-for-url (url &optional (cache (make-hash-table)))
  "First check the in memory cache for warstats, then check the disk storage, then create minimal default stats. Cache is of the format generated by reference-list-for-rooturl. Returned warstats are just for the requested entity, not for the whole tree."
  (or
   (cl-hash-util:hget cache (list url :warstats))
   (multiple-value-bind (spec rid rtype) (%warstats-pathdata-for-url url)
     (when spec
       (let ((path (apply #'make-warstats-path spec)))
         (when (probe-file path)
           (with-open-file (fh path)
             (gethash (if (eq rtype :rooturl) :root rid)
                      (%tidy-loaded-json (json:decode-json fh))))))))
   ;;Don't need a full warstats dict to seed the tree.
   (list :effect 1 :controversy 0)))

;;FIXME: Don't yet have system in place for discussing headlines.
(defun get-headline-for-url (url)
  (multiple-value-bind (id type) (get-target-id-from-url url)
    (hu:collecting-hash-table (:mode :replace)
      (cond
        ((eq type :opinion)
         (let* ((opinion (opinion-by-id id))
                (comment (assoc-cdr :comment opinion)))
           (when comment
             (hu:collect :natural-title comment)
             (hu:collect :title comment))))
        ((eq type :rooturl)
         (when-let ((title (and (is-cached url)
                                (grab-title url :alternate nil :update nil))))
           (hu:collect :natural-title title)
           (hu:collect :title title)))
         ;;FIXME: Don't yet know what to do if reference isn't a target.
        (t nil)))))

(defun refd-opinion-data (opinion)
  (list*
   :refd-opinion-warstats (request-warstats-for-url (assoc-cdr :url opinion))
   :refd-opinion-id (assoc-cdr :id opinion)
   (when-let* ((excerpt (assoc-cdr :excerpt opinion))
               (text (get-target-text (assoc-cdr :id opinion)))
               (textpos (multiple-value-list
                         (find-excerpt-position
                          (create-textdata text) excerpt (or (assoc-cdr :excerpt-offset opinion) 0))))
               (index (elt textpos 0))
               (length (elt textpos 1))
               (econtext (excerpt-context text index length)))
     (list :refd-opinion-excerpt (getf econtext :excerpt)
           :refd-opinion-leading (getf econtext :leading)
           :refd-opinion-trailing (getf econtext :trailing)))))

(defun uri-domain (uri)
  (nth-value 2 (quri:parse-uri uri)))

(defun outgoing-reference-data (id)
  (let* ((refopin (opinion-by-id id))
         (refurl (assoc-cdr :reference refopin))
         (refd-opin (opinion-for-location refurl))
         (refroot (or (and refd-opin (get-rooturl-by-id (assoc-cdr :rooturl refd-opin))) refurl)))
    (assert (stringp refroot))
    `(:reference
      ,refurl
      :reference-domain ,(uri-domain refroot)
      :warflagger-link ,(make-wf-url-for-url refurl)
      :tree-address ,(tree-address id)
      :refbot ,(system-generated-p id)
      :refopinid ,id
      :refopinurl ,(assoc-cdr :url refopin)
      :warstats ,(request-warstats-for-url refroot)
      :warstats-src-url ;;FIXME: do we use this? kind of ugly.
      ,(when-let ((spec (%warstats-pathdata-for-url refroot)))
        (strcat wf/local-settings:*base-url* (apply #'make-warstats-url spec)))
      :headline ,(get-headline-for-url refroot)
      ,@(when refd-opin
          (refd-opinion-data refd-opin)))))

;;Outgoing references
(defun reference-list-for-rooturl (rooturl)
  (ret res (make-hash-table)
    (dolist (id (reference-opinion-ids-for-rooturl rooturl))
      (setf (gethash id res) (hu:plist->hash (outgoing-reference-data id))))))

(defun question-opinion-p (opinid)
  (member (grab-one (liql opinid 'opinion 'opinion.flag))
          '("Negative RaiseQuestion" "Negative NeedsEvidence")
          :test #'equal))

#|
(defun list-of-things-p (opinid)
  (let* ((opinion (opinion-by-id opinid))
         (replies ()))))
|#

(defun question-list-for-rooturl (rooturl warstats)
  (cl-utilities:collecting
    (let ((tree (opinion-tree-for-rooturl rooturl)))
      (labels ((proc (tree location)
                 (dolist (node tree)
                   (when (question-opinion-p (car node))
                     (let ((opin (opinion-by-id (car node))))
                       (cl-utilities:collect
                           (hu:plist->hash
                            (list
                             ;;FIXME: refactor.
                             :tree-address (reverse (cons (car node) location))
                             :questopinid (assoc-cdr :id opin)
                             :questopinurl (assoc-cdr :url opin)
                             :warstats (gethash (car node) warstats))))))
                   (when (cdr node)
                     (proc (cdr node) (cons (car node) location))))))
        (proc tree nil)))))

(defun %prep-for-json (warstats)
  (hu:collecting-hash-table (:mode :replace)
    (gadgets:do-hash-table (k v warstats)
      (hu:collect k (hu:plist->hash v)))))

(defun %prep-references-for-json (references)
  ;;WARNING: Modifies the references table
  (do-hash-table (k ref references)
    (setf (gethash :warstats ref)
          (hu:plist->hash (gethash :warstats ref))))
  references)

(defun write-individual-references (references)
  (do-hash-table (id ref references)
    (let ((opinion (opinion-by-id (gethash :refopinid ref)))
          (statpath (make-warstats-path (gethash :refopinid ref) :opinion)))
      (setf (gethash :opinion ref)
            (hu:alist->hash opinion))
      (uiop/common-lisp:ensure-directories-exist statpath)
      (with-open-file (fh statpath
                         :direction :output :if-exists :supersede
                         :if-does-not-exist :create)
       (json:encode-json ref fh)))))

(defun write-all-rootid-warstats (rootid)
  (let* ((url (get-rooturl-by-id rootid))
         (text (progn
                 (unless (is-cached url)
                   (error "Don't have that page!"))
                 ;;FIXME: Suboptimal place, but somebody has to do it...
                 (make-rooturl-real rootid)
                 (grab-text url)))
         (references (reference-list-for-rooturl url))
         (url-keyed-references
          (hu:collecting-hash-table (:mode :replace :test #'equal)
            (dolist (ref (hash-table-values references))
              (hu:collect (gethash :reference ref) ref))))
         (warstats
          (generate-rooturl-warstats url :reference-cache url-keyed-references)))
    (uiop/common-lisp:ensure-directories-exist (make-warstats-path rootid :opinions))
    (with-open-file (fh (make-warstats-path rootid :opinions)
                        :direction :output :if-exists :supersede
                        :if-does-not-exist :create)
      (json:encode-json (%fill-out-opinion-tree
                         (opinion-tree-for-rooturl url) (create-textdata text))
                        fh))
    (with-open-file (fh (make-warstats-path rootid :warstats)
                        :direction :output :if-exists :supersede
                        :if-does-not-exist :create)
      (json:encode-json (%prep-for-json warstats) fh))
    (with-open-file (fh (make-warstats-path rootid :references)
                        :direction :output :if-exists :supersede
                        :if-does-not-exist :create)
      (%prep-references-for-json references) ;;WARNING: modifies!
      (json:encode-json references fh))
    (write-individual-references references) ;;WARNING: also modifies!
    (with-open-file (fh (make-warstats-path rootid :questions)
                        :direction :output :if-exists :supersede
                        :if-does-not-exist :create)
      (json:encode-json (question-list-for-rooturl url warstats) fh))
    (with-open-file (fh (make-warstats-path rootid :text)
                        :direction :output :if-exists :supersede
                        :if-does-not-exist :create)
      (write-string text fh))
    t))

(defun write-all-warstats ()
  (let ((rurls (all-rooturls))
        (updating nil))
    (dolist (rurl rurls)
      (unless (is-cached rurl)
        (update-page rurl)
        (setf updating t)))
    (when updating
      (sleep 2))
    (dolist (rurl rurls)
      (if (is-cached rurl)
          (write-all-rootid-warstats (get-rooturl-id rurl))
          (format
           t "Didn't process url: ~a~%Reason: ~a" rurl (grab-failed-message rurl))))))
